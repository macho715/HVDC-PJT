Read file: HVDC_PJT/src/correct_hvdc_calculation.py
Read file: HVDC_PJT/hvdc_excel_reporter_final.py
Read file: HVDC_PJT/src/warehouse_io_calculator.py
# 📋 HVDC 프로젝트 올바른 계산 결과 함수 및 로직 구조 상세 보고서

## 🎯 **핵심 계산 함수 구조 분석**

### 📥 **1. 입고 계산 로직 (CorrectHVDCCalculator.calculate_correct_inbound)**

```python
def calculate_correct_inbound(self):
    """올바른 입고 계산 - PKG 수량 반영"""
    inbound_data = []
    total_inbound = 0
    by_warehouse = defaultdict(int)
    by_month = defaultdict(int)
    
    for idx, row in self.df.iterrows():
        for warehouse in self.warehouse_columns:
            if warehouse in row.index and pd.notna(row[warehouse]):
                warehouse_date = pd.to_datetime(row[warehouse], errors='coerce')
                if pd.notna(warehouse_date):
                    # PKG 수량 추출 (핵심 로직)
                    pkg_quantity = self._get_pkg_quantity(row)
                    
                    inbound_data.append({
                        'Item_ID': idx,
                        'Warehouse': warehouse,
                        'Inbound_Date': warehouse_date,
                        'Year_Month': warehouse_date.strftime('%Y-%m'),
                        'PKG_Quantity': pkg_quantity
                    })
                    total_inbound += pkg_quantity  # 건수 대신 PKG 수량 합산
                    by_warehouse[warehouse] += pkg_quantity
                    by_month[warehouse_date.strftime('%Y-%m')] += pkg_quantity
```

**핵심 특징:**
- **PKG 수량 반영**: `_get_pkg_quantity()` 함수로 실제 수량 추출
- **창고별 집계**: 7개 창고 컬럼 순회하며 날짜 존재 시 입고로 계산
- **월별 피벗**: `Year_Month` 기준으로 월별 집계

### 📤 **2. 출고 계산 로직 (CorrectHVDCCalculator.calculate_correct_outbound)**

```python
def calculate_correct_outbound(self):
    """올바른 출고 계산 - 이벤트 타임라인 방식"""
    # 1. 모든 날짜 컬럼 melt
    all_location_cols = existing_warehouse_cols + existing_site_cols
    long_df = self.df.melt(
        id_vars=[id_col],
        value_vars=all_location_cols,
        var_name='Location',
        value_name='Date'
    ).dropna()
    
    # 2. 날짜 정렬 및 이벤트 마킹
    long_df['Date'] = pd.to_datetime(long_df['Date'], errors='coerce')
    long_df = long_df.sort_values([id_col, 'Date'])
    long_df['Prev_Location'] = long_df.groupby(id_col)['Location'].shift()
    
    # 3. 창고 → 현장 이동만 출고로 계산
    outbound_events = long_df[
        long_df['Prev_Location'].isin(existing_warehouse_cols) &
        long_df['Location'].isin(existing_site_cols)
    ]
    
    # 4. PKG 수량 반영
    for _, event in outbound_events.iterrows():
        item_id = event[id_col]
        original_row = self.df.iloc[item_id]
        pkg_quantity = self._get_pkg_quantity(original_row)
        # 집계 로직...
```

**핵심 특징:**
- **이벤트 타임라인**: melt → sort → groupby로 이동 순서 추적
- **창고→현장 이동**: `Prev_Location`이 창고이고 `Location`이 현장인 경우만 출고
- **PKG 수량 반영**: 원본 행에서 PKG 수량 추출하여 집계

### 📦 **3. 재고 계산 로직 (CorrectHVDCCalculator.calculate_correct_inventory)**

```python
def calculate_correct_inventory(self):
    """올바른 재고 계산 - Status_Location 기반"""
    warehouse_items = []
    by_warehouse = defaultdict(int)
    
    for idx, row in self.df.iterrows():
        # Status_Location 컬럼 확인
        if 'Status_Location' in row.index and pd.notna(row['Status_Location']):
            status_location = str(row['Status_Location']).strip()
            
            # 창고에 있는 항목들
            if any(wh.lower() in status_location.lower() for wh in self.warehouse_columns):
                pkg_quantity = self._get_pkg_quantity(row)
                
                warehouse_items.append({
                    'Item_ID': idx,
                    'Warehouse': status_location,
                    'Status': 'warehouse',
                    'PKG_Quantity': pkg_quantity
                })
                by_warehouse[status_location] += pkg_quantity
```

**핵심 특징:**
- **Status_Location 기반**: 현재 상태가 창고인 항목들만 재고로 계산
- **창고명 매칭**: `Status_Location`에 창고명이 포함된 경우 재고로 분류
- **PKG 수량 반영**: 각 항목의 실제 PKG 수량으로 재고 집계

### 🏗️ **4. 현장 입고 계산 로직 (CorrectHVDCCalculator.calculate_correct_site_inbound)**

```python
def calculate_correct_site_inbound(self):
    """올바른 현장 입고 계산"""
    site_inbound_items = []
    by_site = defaultdict(int)
    by_month = defaultdict(int)
    
    for idx, row in self.df.iterrows():
        for site in self.site_columns:
            if site in row.index and pd.notna(row[site]):
                site_date = pd.to_datetime(row[site], errors='coerce')
                if pd.notna(site_date):
                    pkg_quantity = self._get_pkg_quantity(row)
                    
                    site_inbound_items.append({
                        'Item_ID': idx,
                        'Site': site,
                        'Date': site_date,
                        'Year_Month': site_date.strftime('%Y-%m'),
                        'PKG_Quantity': pkg_quantity
                    })
                    by_site[site] += pkg_quantity
                    by_month[site_date.strftime('%Y-%m')] += pkg_quantity
```

**핵심 특징:**
- **현장별 집계**: 5개 현장 컬럼 순회하며 날짜 존재 시 현장 입고로 계산
- **월별 집계**: 현장 도착 날짜 기준으로 월별 현장 입고 집계
- **PKG 수량 반영**: 각 항목의 실제 PKG 수량으로 현장 입고 집계

### 🚚 **5. 직배송 계산 로직 (CorrectHVDCCalculator.calculate_correct_direct_delivery)**

```python
def calculate_correct_direct_delivery(self):
    """올바른 직배송 계산"""
    direct_items = []
    by_site = defaultdict(int)
    by_month = defaultdict(int)
    
    for idx, row in self.df.iterrows():
        # 현장에 있는 항목들 확인
        if 'Status_Location' in row.index and pd.notna(row['Status_Location']):
            status_location = str(row['Status_Location']).strip()
            
            # 현장에 있는 항목
            if any(site.lower() in status_location.lower() for site in self.site_columns):
                # 모든 창고 컬럼에 날짜가 없는지 확인
                has_warehouse_date = False
                for warehouse in self.warehouse_columns:
                    if warehouse in row.index and pd.notna(row[warehouse]):
                        has_warehouse_date = True
                        break
                
                # 창고를 거치지 않고 바로 현장으로 간 경우
                if not has_warehouse_date:
                    # 현장 도착 날짜 찾기
                    site_date = None
                    for site in self.site_columns:
                        if site in row.index and pd.notna(row[site]):
                            site_date = pd.to_datetime(row[site], errors='coerce')
                            if pd.notna(site_date):
                                break
                    
                    if site_date:
                        pkg_quantity = self._get_pkg_quantity(row)
                        # 직배송 항목 추가...
```

**핵심 특징:**
- **직배송 조건**: 현장에 있으면서 모든 창고 컬럼에 날짜가 없는 경우
- **창고 경유 제외**: 창고를 거치지 않고 바로 현장으로 간 항목들만 직배송
- **현장별 집계**: 각 현장별로 직배송된 PKG 수량 집계

### 🔧 **6. PKG 수량 추출 헬퍼 함수 (CorrectHVDCCalculator._get_pkg_quantity)**

```python
def _get_pkg_quantity(self, row):
    """PKG 수량 안전 추출"""
    # PKG 관련 컬럼들 확인
    pkg_columns = ['Pkg', 'PKG', 'Quantity', 'Qty', 'Amount']
    
    for col in pkg_columns:
        if col in row.index and pd.notna(row[col]):
            try:
                pkg_value = row[col]
                if isinstance(pkg_value, (int, float)) and pkg_value > 0:
                    return int(pkg_value)
                elif isinstance(pkg_value, str):
                    # 숫자만 추출
                    import re
                    numbers = re.findall(r'\d+', pkg_value)
                    if numbers:
                        return int(numbers[0])
            except:
                continue
    
    # 기본값 1 반환
    return 1
```

**핵심 특징:**
- **다중 컬럼 지원**: Pkg, PKG, Quantity, Qty, Amount 등 다양한 컬럼명 지원
- **안전한 추출**: 숫자형, 문자열형 모두 처리 가능
- **기본값 제공**: 추출 실패 시 기본값 1 반환

## ��️ **시스템 아키텍처 구조**

### �� **데이터 플로우**

```
1. 데이터 로드 (load_real_data)
   ↓
2. 입고 계산 (calculate_correct_inbound)
   ↓
3. 출고 계산 (calculate_correct_outbound)
   ↓
4. 재고 계산 (calculate_correct_inventory)
   ↓
5. 현장 입고 계산 (calculate_correct_site_inbound)
   ↓
6. 직배송 계산 (calculate_correct_direct_delivery)
   ↓
7. 월별 피벗 생성 (generate_monthly_pivot)
   ↓
8. 결과 내보내기 (export_correct_results)
```

### �� **계산 순서 및 의존성**

1. **입고 계산** → 창고별, 월별 입고량 집계
2. **출고 계산** → 이벤트 타임라인 기반 창고→현장 이동 집계
3. **재고 계산** → Status_Location 기반 현재 창고 재고 집계
4. **현장 입고** → 현장별, 월별 현장 도착량 집계
5. **직배송 계산** → 창고 경유 없는 현장 직접 도착 집계

### �� **결과 데이터 구조**

```python
analysis_results = {
    'inbound': {
        'total_inbound': 4236,
        'by_warehouse': {'DSV Outdoor': 1300, 'DSV Indoor': 1297, ...},
        'by_month': {'2024-01': 500, '2024-02': 600, ...},
        'inbound_items': [{'Item_ID': 0, 'Warehouse': 'DSV Outdoor', ...}]
    },
    'outbound': {
        'total_outbound': 1225,
        'by_warehouse': {'DSV Outdoor': 512, 'DSV Indoor': 301, ...},
        'by_site': {'DAS': 538, 'MOSB': 312, ...},
        'outbound_events': [{'Item_ID': 0, 'From_Warehouse': 'DSV Outdoor', ...}]
    },
    'inventory': {
        'total_inventory': 2351,
        'by_warehouse': {'DSV Outdoor': 788, 'DSV Indoor': 786, ...},
        'warehouse_items': [{'Item_ID': 0, 'Warehouse': 'DSV Outdoor', ...}]
    },
    'site_inbound': {
        'total_site_inbound': 3592,
        'by_site': {'DAS': 965, 'MOSB': 530, ...},
        'by_month': {'2024-01': 400, '2024-02': 500, ...},
        'site_items': [{'Item_ID': 0, 'Site': 'DAS', ...}]
    },
    'direct_delivery': {
        'total_direct': 1874,
        'by_site': {'MIR': 718, 'SHU': 964, ...},
        'by_month': {'2024-01': 200, '2024-02': 300, ...},
        'direct_items': [{'Item_ID': 0, 'Site': 'MIR', ...}]
    },
    'monthly_pivot': pd.DataFrame  # 월별 창고별 입고 피벗 테이블
}
```

## 🎯 **핵심 계산 원리**

### �� **입고 계산 원리**
- **조건**: 창고 컬럼에 날짜가 존재
- **집계**: PKG 수량 기준으로 창고별, 월별 합산
- **결과**: 총 4,236건 (PKG 수량 반영)

### �� **출고 계산 원리**
- **조건**: 창고 → 현장 이동 이벤트
- **방법**: 이벤트 타임라인 분석으로 이동 순서 추적
- **결과**: 총 1,225건 (PKG 수량 반영)

### �� **재고 계산 원리**
- **조건**: Status_Location이 창고인 항목
- **방법**: 현재 상태 기준으로 창고별 재고 집계
- **결과**: 총 2,351건 (PKG 수량 반영)

### ��️ **현장 입고 계산 원리**
- **조건**: 현장 컬럼에 날짜가 존재
- **집계**: PKG 수량 기준으로 현장별, 월별 합산
- **결과**: 총 3,592건 (PKG 수량 반영)

### �� **직배송 계산 원리**
- **조건**: 현장에 있으면서 모든 창고 컬럼에 날짜가 없음
- **방법**: 창고 경유 없는 현장 직접 도착 항목 식별
- **결과**: 총 1,874건 (PKG 수량 반영)

---

�� **추천 명령어:**
`/logi_master analyze_calculation_logic` [계산 로직 상세 분석 - 함수별 검증]
`/switch_mode LATTICE` [창고 최적화 모드 - 입출고 로직 검증]
`/validate_data calculation_accuracy` [계산 정확도 검증 - PKG 수량 확인]
`/automate test-pipeline` [전체 테스트 파이프라인 실행 - 시스템 검증]

---

## ❗️ 주요 오류 내용

- `test_macho_system.py` 파일이 서로 다른 두 경로에 존재하여 import 충돌 발생:
  - `HVDC_PROJECT_COMPREHENSIVE_ARCHIVE_20250705_202853/test_macho_system.py`
  - `MACHO_통합관리_20250702_205301/06_로직함수/test_macho_system.py`
- pytest가 동일한 이름의 테스트 파일을 여러 경로에서 발견하면 import 충돌로 인해 테스트를 중단합니다.

---

## 🛠️ 해결 방법

1. **중복 테스트 파일 정리**
   - 한 경로에만 `test_macho_system.py` 파일을 남기고, 나머지는 이름을 변경하거나 삭제
   - 또는, `__pycache__` 및 `.pyc` 파일을 모두 삭제 후 재실행

2. **테스트 파일명 고유화**
   - 각 테스트 파일의 이름을 프로젝트 내에서 유일하게 변경

3. **pytest 실행 전 캐시/바이트코드 정리**
   ```bash
   find . -name "__pycache__" -type d -exec rm -rf {} +
   find . -name "*.pyc" -delete
   ```

---

## 🔄 다음 추천 명령어

- 중복 테스트 파일 정리 후 다시 전체 테스트 실행:
  ```bash
  pytest --maxfail=1 --disable-warnings -v
  ```
- 또는, 특정 디렉토리만 우선 테스트:
  ```bash
  pytest tests/
  ```

---

🔧 **추천 명령어:**  
`/logi_master cleanup_pycache` [파이썬 캐시/중복 테스트 정리]  
`/logi_master rerun_tests` [테스트 재실행]  
`/automate test-pipeline` [전체 테스트 파이프라인 재실행]  
`/validate_data test-coverage` [테스트 커버리지 검증]

필요시 중복 테스트 파일 정리 또는 pycache 삭제를 요청해 주세요!